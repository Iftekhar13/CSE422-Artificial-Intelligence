# -*- coding: utf-8 -*-
"""Lab02

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17U2oapvZZNkA2ytZVJ2ua1HTXpXrmCI-
"""

import random

def string_generate(length):              #to generate a random binary string
    return ''.join(str(random.randint(0, 1)) for _ in range(length))

def fitness_calculation(fitness_array, benefit_array, test_string):   # calculates the fitness of a given binary string (test_string)
    total = 0                                                         # based on the provided fitness_array and benefit_array.
    for i in range(len(test_string)):
        if test_string[i] == '1':  #This line checks if the current binary digit (character) in the test_string is equal to '1'
            if fitness_array[i] == 'l':   #This line checks the corresponding fitness value at index i in the fitness_array
                total -= benefit_array[i]
            else:
                total += benefit_array[i]
    return total

def crossover(parent1, parent2):             #performs crossover between two parent binary strings (parent1 and parent2)
    split_point = random.randint(1, len(parent1) - 1)
    child1 = parent1[:split_point] + parent2[split_point:] #creates two children by combining the substrings
    child2 = parent2[:split_point] + parent1[split_point:] #of each parent from the split point.
    return [child1, child2]

def mutation(string):                          #It randomly selects an index between 0 and len(string) - 1
    index = random.randint(0, len(string) - 1) #and changes the character at that index to its complement
    mutated_string = list(string)
    mutated_string[index] = '1' if mutated_string[index] == '0' else '0'
    return ''.join(mutated_string)

def solve(fitness_array, benefit_array): # It takes fitness_array and benefit_array as inputs
    population_size = 10                 # It initializes the population size to 10 and the maximum number of generations to 10000
    generations = 10000

    population = [string_generate(len(fitness_array)) for _ in range(population_size)] #generates a population of random binary strings
    answer = '-1'

    for _ in range(generations):
        for chromosome in population:  #iterates over each chromosome (binary string) in the population and checks if its fitness, calculated using the calculate_fitness function, is equal to 0
            if fitness_calculation(fitness_array, benefit_array, chromosome) == 0 and int(chromosome) != 0: #and the integer value of the chromosome is not 0.
                answer = chromosome    #If a chromosome meets these conditions, it assigns it to the answer
                break

        if answer != '-1':
            break
                            #If no solution is found
        new_population = [] #it creates a new population by performing crossover between randomly selected parents
                            #and storing the offspring in new_population
        for _ in range(population_size // 2):
            parents = random.sample(population, 2)
            offspring = crossover(parents[0], parents[1])
            new_population.extend(offspring)

        population = [mutation(chromosome) for chromosome in new_population]

    return answer

fitness_array = ['l', 'l', 'd', 'l', 'd',]
benefit_array = [100, 450, 500, 7923, 9055]

answer = solve(fitness_array, benefit_array)
print(answer)